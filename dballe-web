#!/usr/bin/env python3
import webbrowser
import selectors
import datetime
import argparse
import logging
import getpass
import socket
import locale
import curses
import os
import sys
from dballe_web.application import create_app, Server, StopServer

try:
    import coloredlogs
except ModuleNotFoundError:
    coloredlogs = None

VERSION = "0.2"

log = logging.getLogger("dballe-web")


class DballeWeb:
    def __init__(self, args):
        self.args = args
        self.start_url = None
        self.port = None
        self.forwarded_start_url = None

        if args.debug:
            self.log_level = logging.DEBUG
        elif args.verbose:
            self.log_level = logging.INFO
        else:
            self.log_level = logging.WARN

    def start_flask(self):
        app = create_app(self.args.db)

        server = Server(
                host='127.0.0.1',
                port=0 if self.args.port is None else int(self.args.port),
                app=app)

        self.port = server.socket.getsockname()[1]
        if self.args.devel:
            app.access_token = None
            self.start_url = f"http://localhost:{self.port}"
            self.forwarded_start_url = f"http://localhost:5000/"
        else:
            self.start_url = f"http://localhost:{self.port}/start/{app.access_token}"
            self.forwarded_start_url = f"http://localhost:5000/start/{app.access_token}"

        return server


class CLI(DballeWeb):
    def start(self):
        FORMAT = "%(asctime)-15s %(levelname)s %(name)s %(message)s"

        if coloredlogs is not None:
            coloredlogs.install(level=self.log_level, fmt=FORMAT, stream=sys.stderr)
        else:
            logging.basicConfig(level=self.log_level, stream=sys.stderr, format=FORMAT)

        self.server = self.start_flask()

        print(f" * Running on {self.start_url} (Press CTRL+C to quit)")
        print(f" * Port forwarding command: ssh {getpass.getuser()}@{socket.getfqdn()} -NL 5000:localhost:{self.port}")
        print(f" * Port forwarding URL: {self.forwarded_start_url}")

        self.server.serve_forever()


class CursesHandler(logging.Handler):
    def __init__(self, window, level=logging.NOTSET):
        super().__init__(level)
        self.window = window
        self.window.scrollok(True)
        self.window.idlok(True)
        self.window.leaveok(True)

        # Screen attributes for the given log messages
        # Default RGB values for these colors are set in the Palette configuration of the terminal
        normal = curses.A_NORMAL
        if curses.COLOR_PAIRS < 6:
            self.log_attrs = {
                logging.DEBUG: (normal, normal),
                logging.INFO: (normal, normal),
                logging.WARNING: (normal, normal),
                logging.ERROR: (normal, normal),
                logging.CRITICAL: (normal, normal),
            }
        else:
            curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLACK)
            curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
            curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
            curses.init_pair(4, curses.COLOR_RED, curses.COLOR_BLACK)
            curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_RED)

            self.log_attrs = {
                logging.DEBUG: (curses.color_pair(1) | curses.A_DIM, normal | curses.A_DIM),
                logging.INFO: (curses.color_pair(2), normal),
                logging.WARNING: (curses.color_pair(3), normal),
                logging.ERROR: (curses.color_pair(4), normal),
                logging.CRITICAL: (curses.color_pair(5), normal),
            }

    def emit(self, record):
        maxy, maxx = self.window.getmaxyx()
        posy, posx = self.window.getyx()

        if posy == maxy:
            self.window.scroll()

        try:
            # TODO: remove ANSI sequences from werkzeug logs
            message = record.getMessage()
            dt = datetime.datetime.fromtimestamp(record.created)

            attr_head, attr_msg = self.log_attrs[record.levelno]

            x = 0

            def add(s: str, attr=0):
                nonlocal x
                self.window.addstr(posy, x, s, attr)
                x += len(s)

            add(dt.strftime("%Y-%m-%d %H:%M:%S"), attr_head)
            x += 1
            add(record.levelname[0], attr_head)
            x += 1
            add(message[:maxx - x], attr_msg)

            if posy < maxy:
                self.window.move(posy + 1, 0)

            self.window.refresh()
        except Exception:
            raise
            # TODO: if a problem happens here, figure out how to log it / show it
            # self.handleError(record)


class TUI(DballeWeb):
    def __init__(self, args):
        super().__init__(args)
        self.command_thread = None
        self.server = None
        self.stdscr = None

    def start(self):
        logging.getLogger().setLevel(self.log_level)

        curses.wrapper(self.tui_main)

    def on_stdin(self, events):
        maxy, maxx = self.stdscr.getmaxyx()

        key = self.stdscr.getch()
        if key in (ord('q'), ord('Q')):
            raise StopServer()
        elif key == ord('w'):
            webbrowser.open(self.start_url)
        elif key == ord('W'):
            webbrowser.open(self.forwarded_start_url)
        # TODO: add a key to dump logs

    def tui_main(self, stdscr):
        # TODO: handle window resize
        maxy, maxx = stdscr.getmaxyx()
        self.stdscr = stdscr
        self.stdscr.timeout(0)
        curses.curs_set(0)

        # External border
        self.stdscr.border()

        # Horizontal separator line
        self.stdscr.addch(4, 0, curses.ACS_LTEE)
        for x in range(1, maxx - 1):
            self.stdscr.addch(4, x, curses.ACS_HLINE)
        self.stdscr.addch(4, maxx - 1, curses.ACS_RTEE)

        # TODO: show menu
        # TODO: handle tracebacks from code
        #        - turn log window into a class, with methods to add log lines
        #          and also a method to add a traceback?
        #        - make it scroll up/down with arrows?

        # Setup logging to a window
        FORMAT = "%(asctime)-15s %(levelname)s %(name)s %(message)s"
        formatter = logging.Formatter(FORMAT, style='%')

        log_height = maxy - 4
        log_window = curses.newwin(log_height - 2, maxx - 2, maxy - log_height + 1, 1)

        handler = CursesHandler(log_window)
        handler.setFormatter(formatter)
        logging.getLogger().addHandler(handler)

        self.server = self.start_flask()

        # Header information
        stdscr.addstr(1, 1, f"Running on {self.start_url} (Press 'q' to quit))")
        stdscr.addstr(
                2, 1,
                f"Port forwarding command: ssh {getpass.getuser()}@{socket.getfqdn()} -NL 5000:localhost:{self.port}")
        stdscr.addstr(3, 1, f"Port forwarding URL: {self.forwarded_start_url}")

        stdscr.refresh()

        self.server.serve_forever(events=(
            (sys.stdin, selectors.EVENT_READ, self.on_stdin),
        ))


def main():
    parser = argparse.ArgumentParser(
            description="Explore a DB-All.e database interactively using a web interface")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="verbose output")
    parser.add_argument("--debug", action="store_true",
                        help="verbose output")
    parser.add_argument("--port", "--web-port", type=str, default=None,
                        help="listening port for web interface. Default: automatically allocate a free port")
    parser.add_argument("--devel", action="store_true",
                        help="development mode: disable access token checks to allow restarting dballe-web"
                             " without needing to restart the browser session")
    parser.add_argument("db", type=str, metavar="dballe_url", default=os.environ.get("DBA_DB"),
                        help="DB-All.e database to connect to")
    args = parser.parse_args()

    locale.setlocale(locale.LC_ALL, '')

    if True:
        app = TUI(args)
    else:
        app = CLI(args)
    app.start()


if __name__ == "__main__":
    sys.exit(main())
